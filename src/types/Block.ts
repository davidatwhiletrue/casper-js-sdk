import { jsonObject, jsonMember, jsonArrayMember } from 'typedjson';
import { Hash } from './key';
import { Timestamp } from './Time';
import { Proposer } from './BlockProposer';
import { EraEnd, EraEndV1, EraEndV2 } from './EraEnd';
import {
  TransactionCategory,
  TransactionHash,
  TransactionVersion
} from './Transaction';
import { PublicKey } from './keypair';
import { HexBytes } from './HexBytes';

/**
 * Represents a proof containing a public key and a signature, used for validating the authenticity of data.
 */
@jsonObject
export class Proof {
  /**
   * The public key associated with the proof.
   * This key is used to verify the signature's validity.
   */
  @jsonMember(() => ({
    constructor: PublicKey,
    name: 'public_key',
    deserializer: (json: string) => PublicKey.fromJSON(json),
    serializer: (value: PublicKey) => value.toJSON()
  }))
  public publicKey: PublicKey;

  /**
   * The signature generated by the associated public key.
   * The signature proves the authenticity of the data or transaction.
   */
  @jsonMember(() => ({
    name: 'signature',
    constructor: HexBytes,
    deserializer: (json: string) => HexBytes.fromJSON(json),
    serializer: (value: HexBytes) => value.toJSON()
  }))
  public signature: HexBytes;
}

/**
 * Represents a block in the blockchain containing metadata, transactions, and proof.
 * A block includes information like the hash, height, parent block, transactions, and more.
 */
@jsonObject
export class Block {
  /**
   * The unique hash of the block.
   */
  @jsonMember(() => ({
    name: 'hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public hash: Hash;

  /**
   * The height of the block in the blockchain.
   */
  @jsonMember({ name: 'height', constructor: Number })
  public height: number;

  /**
   * The hash of the state root associated with the block.
   */
  @jsonMember(() => ({
    name: 'state_root_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public stateRootHash: Hash;

  /**
   * The hash of the block that switched the current state, if available.
   * This can be `null` if not applicable.
   */
  @jsonMember(() => ({
    name: 'last_switch_block_hash',
    constructor: Hash,
    deserializer: (json: string) => (json ? Hash.fromJSON(json) : null),
    serializer: (value: Hash) => (value ? value.toJSON() : null),
    preserveNull: true
  }))
  public lastSwitchBlockHash: Hash | null;

  /**
   * The hash of the parent block in the blockchain.
   */
  @jsonMember(() => ({
    name: 'parent_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public parentHash: Hash;

  /**
   * The era ID in which this block was created.
   */
  @jsonMember({ name: 'era_id', constructor: Number })
  public eraID: number;

  /**
   * The timestamp indicating when the block was created.
   */
  @jsonMember(() => ({
    name: 'timestamp',
    constructor: Timestamp,
    deserializer: (json: string) => Timestamp.fromJSON(json),
    serializer: (value: Timestamp) => value.toJSON()
  }))
  public timestamp: Timestamp;

  /**
   * The accumulated seed for randomness in the block generation.
   */
  @jsonMember(() => ({
    name: 'accumulated_seed',
    constructor: Hash,
    deserializer: (json: string) => {
      if (!json) return;
      return Hash.fromJSON(json);
    },
    serializer: (value: Hash) => {
      if (!value) return;
      return value.toJSON();
    }
  }))
  public accumulatedSeed?: Hash;

  /**
   * A random bit used for proof-of-stake consensus.
   */
  @jsonMember({ name: 'random_bit', constructor: Boolean })
  public randomBit: boolean;

  /**
   * The current gas price for transactions included in the block.
   */
  @jsonMember({ name: 'current_gas_price', constructor: Number })
  public currentGasPrice: number;

  /**
   * The proposer who created this block.
   */
  @jsonMember(() => ({
    name: 'proposer',
    constructor: Proposer,
    deserializer: (json: string) => Proposer.fromJSON(json),
    serializer: (value: Proposer) => value.toJSON()
  }))
  public proposer: Proposer;

  /**
   * The protocol version used for this block.
   */
  @jsonMember({ name: 'protocol_version', constructor: String })
  public protocolVersion?: string;

  /**
   * The era end details, if available, for the block's era.
   */
  @jsonMember(() => ({ name: 'era_end', constructor: EraEnd }))
  public eraEnd?: EraEnd;

  /**
   * The list of transactions included in this block.
   */
  @jsonArrayMember(() => BlockTransaction, {
    name: 'transactions',
    deserializer: (json: string) => BlockTransaction.fromJSON(json)
  })
  public transactions: BlockTransaction[];

  /**
   * A list of signature IDs that were rewarded in this block.
   */
  @jsonArrayMember(Number, { name: 'rewarded_signatures' })
  public rewardedSignatures: number[];

  /**
   * A list of proofs associated with this block.
   */
  @jsonArrayMember(() => Proof, { name: 'proofs' })
  public proofs: Proof[];

  /**
   * The origin block in V1 format, if available.
   */
  public originBlockV1?: BlockV1;

  /**
   * The origin block in V2 format, if available.
   */
  public originBlockV2?: BlockV2;

  /**
   * Constructs a new `Block` instance.
   * @param hash - The unique hash of the block.
   * @param height - The height of the block in the blockchain.
   * @param stateRootHash - The hash of the state root for the block.
   * @param lastSwitchBlockHash - The hash of the block that switched the state, if available.
   * @param parentHash - The hash of the parent block.
   * @param eraID - The era ID in which the block was created.
   * @param timestamp - The timestamp of the block creation.
   * @param accumulatedSeed - The accumulated seed for randomness in the block.
   * @param randomBit - A random bit used for consensus.
   * @param currentGasPrice - The current gas price for transactions in the block.
   * @param proposer - The proposer of the block.
   * @param protocolVersion - The protocol version of the block.
   * @param eraEnd - The era end details for the block's era, if available.
   * @param transactions - The list of transactions included in the block.
   * @param rewardedSignatures - The list of rewarded signatures.
   * @param proofs - The list of proofs associated with the block.
   * @param originBlockV1 - The origin block in V1 format, if available.
   * @param originBlockV2 - The origin block in V2 format, if available.
   */
  constructor(
    hash: Hash,
    height: number,
    stateRootHash: Hash,
    lastSwitchBlockHash: Hash | null,
    parentHash: Hash,
    eraID: number,
    timestamp: Timestamp,
    accumulatedSeed: Hash | undefined,
    randomBit: boolean,
    currentGasPrice: number,
    proposer: Proposer,
    protocolVersion: string | undefined,
    eraEnd: EraEnd | undefined,
    transactions: BlockTransaction[],
    rewardedSignatures: number[],
    proofs: Proof[],
    originBlockV1?: BlockV1,
    originBlockV2?: BlockV2
  ) {
    this.hash = hash;
    this.height = height;
    this.stateRootHash = stateRootHash;
    this.lastSwitchBlockHash = lastSwitchBlockHash;
    this.parentHash = parentHash;
    this.eraID = eraID;
    this.timestamp = timestamp;
    this.accumulatedSeed = accumulatedSeed;
    this.randomBit = randomBit;
    this.currentGasPrice = currentGasPrice;
    this.proposer = proposer;
    this.protocolVersion = protocolVersion;
    this.eraEnd = eraEnd;
    this.transactions = transactions;
    this.rewardedSignatures = rewardedSignatures;
    this.proofs = proofs;
    this.originBlockV1 = originBlockV1;
    this.originBlockV2 = originBlockV2;
  }

  /**
   * Retrieves the V1 format of the origin block, if available.
   * @returns The origin block in V1 format, or `undefined` if not available.
   */
  getBlockV1(): BlockV1 | undefined {
    return this.originBlockV1;
  }

  /**
   * Retrieves the V2 format of the origin block, if available.
   * @returns The origin block in V2 format, or `undefined` if not available.
   */
  getBlockV2(): BlockV2 | undefined {
    return this.originBlockV2;
  }

  /**
   * Creates a new `Block` instance from a `BlockWrapper` object, which may contain either V1 or V2 block format.
   * @param blockWrapper - The `BlockWrapper` containing either `blockV1` or `blockV2`.
   * @param proofs - The list of proofs associated with the block.
   * @returns A new `Block` instance based on the provided `blockWrapper` and `proofs`.
   * @throws Will throw an error if the `blockWrapper` does not contain a valid `blockV1` or `blockV2`.
   */
  static newBlockFromBlockWrapper(
    blockWrapper: BlockWrapper,
    proofs: Proof[]
  ): Block {
    if (blockWrapper.blockV1) {
      const block = Block.newBlockFromBlockV1(blockWrapper.blockV1);
      block.proofs = proofs;
      return block;
    } else if (blockWrapper.blockV2) {
      const blockV2 = blockWrapper.blockV2;
      return new Block(
        blockV2.hash,
        blockV2.header.height,
        blockV2.header.stateRootHash,
        blockV2.header.lastSwitchBlockHash,
        blockV2.header.parentHash,
        blockV2.header.eraID,
        blockV2.header.timestamp,
        blockV2.header.accumulatedSeed,
        blockV2.header.randomBit,
        blockV2.header.currentGasPrice,
        blockV2.header.proposer,
        blockV2.header.protocolVersion,
        EraEnd.fromV2(blockV2.header.eraEnd ?? null) ?? undefined,
        blockV2.body.transactions,
        blockV2.body.rewardedSignatures,
        proofs,
        undefined,
        blockV2
      );
    }
    throw new Error('BlockWrapper must contain either BlockV1 or BlockV2');
  }

  /**
   * Creates a new `Block` instance from a V1 block format.
   * @param blockV1 - The V1 block format.
   * @returns A new `Block` instance created from the provided V1 block format.
   */
  static newBlockFromBlockV1(blockV1: BlockV1): Block {
    const blockTransactions: BlockTransaction[] = [];

    for (const transferHash of blockV1.body.transferHashes) {
      blockTransactions.push(
        new BlockTransaction(
          TransactionCategory.Mint,
          TransactionVersion.Deploy,
          transferHash
        )
      );
    }

    for (const deployHash of blockV1.body.deployHashes) {
      blockTransactions.push(
        new BlockTransaction(
          TransactionCategory.Large,
          TransactionVersion.Deploy,
          deployHash
        )
      );
    }

    return new Block(
      blockV1.hash,
      blockV1.header.height,
      blockV1.header.stateRootHash,
      null,
      blockV1.header.parentHash,
      blockV1.header.eraID,
      blockV1.header.timestamp,
      blockV1.header.accumulatedSeed,
      blockV1.header.randomBit,
      1,
      blockV1.body.proposer,
      blockV1.header.protocolVersion,
      EraEnd.fromV1(blockV1.header.eraEnd ?? null) ?? undefined,
      blockTransactions,
      [],
      blockV1.proofs,
      blockV1
    );
  }
}

/**
 * Represents a transaction within a block, identified by a category, version, and hash.
 * Each `BlockTransaction` stores the category of the transaction, its version, and a unique hash.
 */
@jsonObject
export class BlockTransaction {
  /**
   * The category of the transaction, indicating the type of transaction.
   * This could be one of the predefined categories such as Mint, Auction, InstallUpgrade, etc.
   */
  @jsonMember({ name: 'category', constructor: Number })
  public category: TransactionCategory;

  /**
   * The version of the transaction, specifying the version of the transaction protocol.
   */
  @jsonMember({ name: 'version', constructor: Number })
  public version: TransactionVersion;

  /**
   * The unique hash identifying the transaction.
   * This hash serves as a reference to the transaction.
   */
  @jsonMember(() => ({
    name: 'hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public hash: Hash;

  /**
   * Constructs a new `BlockTransaction` instance.
   * @param category - The category of the transaction (e.g., Mint, Auction).
   * @param version - The version of the transaction protocol.
   * @param hash - The unique hash identifying the transaction.
   */
  constructor(
    category: TransactionCategory,
    version: TransactionVersion,
    hash: Hash
  ) {
    this.category = category;
    this.version = version;
    this.hash = hash;
  }

  /**
   * Deserializes a JSON object into an array of `BlockTransaction` instances.
   * The input `data` is expected to contain transaction hashes categorized by their types.
   *
   * @param data - The serialized data representing transactions categorized by type.
   * @returns An array of `BlockTransaction` instances.
   *
   * @example
   * const jsonData = { '0': ['hash1', 'hash2'], '1': ['hash3'] };
   * const transactions = BlockTransaction.fromJSON(jsonData);
   * console.log(transactions); // Outputs an array of BlockTransaction instances.
   */
  public static fromJSON(data: any): BlockTransaction[] {
    const source = {
      Mint: data['0'] || [],
      Auction: data['1'] || [],
      InstallUpgrade: data['2'] || [],
      Large: data['3'] || [],
      Medium: data['4'] || [],
      Small: data['5'] || []
    };

    const transactions: BlockTransaction[] = [];
    transactions.push(
      ...getBlockTransactionsFromTransactionHashes(
        source.Mint,
        TransactionCategory.Mint
      ),
      ...getBlockTransactionsFromTransactionHashes(
        source.Auction,
        TransactionCategory.Auction
      ),
      ...getBlockTransactionsFromTransactionHashes(
        source.InstallUpgrade,
        TransactionCategory.InstallUpgrade
      ),
      ...getBlockTransactionsFromTransactionHashes(
        source.Large,
        TransactionCategory.Large
      ),
      ...getBlockTransactionsFromTransactionHashes(
        source.Medium,
        TransactionCategory.Medium
      ),
      ...getBlockTransactionsFromTransactionHashes(
        source.Small,
        TransactionCategory.Small
      )
    );

    return transactions;
  }
}

/**
 * Converts an array of `TransactionHash` objects into an array of `BlockTransaction` instances.
 * Each `TransactionHash` is associated with a specific category, and the resulting `BlockTransaction` includes the category,
 * version, and the hash of the transaction.
 *
 * @param hashes - An array of `TransactionHash` objects, each representing a transaction hash.
 * @param category - The category of the transaction (e.g., Mint, Auction).
 * @returns An array of `BlockTransaction` instances, each representing a transaction.
 *
 * @throws {Error} If any of the `TransactionHash` objects does not contain a valid `transactionV1`.
 *
 */
function getBlockTransactionsFromTransactionHashes(
  hashes: TransactionHash[],
  category: TransactionCategory
): BlockTransaction[] {
  if (hashes.length === 0) {
    return [];
  }

  return hashes.map(hash => {
    const transactionHash = hash.transactionV1;

    if (!transactionHash) {
      throw new Error('Invalid TransactionHash: transactionV1 is undefined');
    }

    return new BlockTransaction(
      category,
      TransactionVersion.V1,
      transactionHash
    );
  });
}

/**
 * Parses a JSON string representing block transactions and converts them into an array of `BlockTransaction` instances.
 * The input data is expected to be a JSON object with categories (e.g., '0', '1', etc.) mapping to arrays of `TransactionHash` objects.
 * Each category corresponds to a specific type of transaction, such as Mint, Auction, etc.
 *
 * @param data - A JSON string containing transaction categories as keys ('0', '1', etc.), with each key pointing to an array of `TransactionHash` objects.
 * @returns An array of `BlockTransaction` instances representing the transactions in the block.
 *
 * @throws {Error} If the input `data` is not valid JSON or does not conform to the expected structure.
 *
 * @example
 * const jsonData = '{"0": [{"transactionV1": "hash1"}], "1": [{"transactionV1": "hash2"}]}';
 * const transactions = parseBlockTransactions(jsonData);
 * console.log(transactions); // Outputs an array of BlockTransaction instances for Mint and Auction transactions.
 */
export function parseBlockTransactions(data: string): BlockTransaction[] {
  const source = JSON.parse(data) as {
    '0'?: TransactionHash[];
    '1'?: TransactionHash[];
    '2'?: TransactionHash[];
    '3'?: TransactionHash[];
    '4'?: TransactionHash[];
    '5'?: TransactionHash[];
  };

  const result: BlockTransaction[] = [];

  if (source['0'])
    result.push(
      ...getBlockTransactionsFromTransactionHashes(
        source['0'],
        TransactionCategory.Mint
      )
    );
  if (source['1'])
    result.push(
      ...getBlockTransactionsFromTransactionHashes(
        source['1'],
        TransactionCategory.Auction
      )
    );
  if (source['2'])
    result.push(
      ...getBlockTransactionsFromTransactionHashes(
        source['2'],
        TransactionCategory.InstallUpgrade
      )
    );
  if (source['3'])
    result.push(
      ...getBlockTransactionsFromTransactionHashes(
        source['3'],
        TransactionCategory.Large
      )
    );
  if (source['4'])
    result.push(
      ...getBlockTransactionsFromTransactionHashes(
        source['4'],
        TransactionCategory.Medium
      )
    );
  if (source['5'])
    result.push(
      ...getBlockTransactionsFromTransactionHashes(
        source['5'],
        TransactionCategory.Small
      )
    );

  return result;
}

/**
 * Represents a version 1 block in the blockchain, including the block's metadata (header), body, and proofs.
 * A `BlockV1` contains the block's unique hash, header (which includes metadata like height and era ID), body (which includes transactions),
 * and an array of proofs related to the block.
 */
@jsonObject
export class BlockV1 {
  /**
   * The unique hash of the block, used to identify and verify the block in the blockchain.
   */
  @jsonMember(() => ({
    name: 'hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public hash: Hash;

  /**
   * The header of the block, containing metadata such as block height, era ID, and timestamp.
   */
  @jsonMember({ name: 'header', constructor: () => BlockHeaderV1 })
  public header: BlockHeaderV1;

  /**
   * The body of the block, which contains the transactions and related data for the block.
   */
  @jsonMember({ name: 'body', constructor: () => BlockBodyV1 })
  public body: BlockBodyV1;

  /**
   * An array of proofs associated with the block, used to verify the authenticity of the block.
   */
  @jsonArrayMember(Proof, { name: 'proofs' })
  public proofs: Proof[];
}

/**
 * Represents the body of a version 1 block in the blockchain.
 * The body contains essential data related to transactions, deploys, and other actions within the block.
 */
@jsonObject
export class BlockBodyV1 {
  /**
   * The list of deploy hashes included in the block.
   * Deploys represent the transactions that are being executed within this block.
   */
  @jsonArrayMember(() => Hash, {
    name: 'deploy_hashes',
    serializer: (value: Hash[]) => value.map(it => it.toJSON()),
    deserializer: (json: any) => json.map((it: string) => Hash.fromJSON(it))
  })
  public deployHashes: Hash[];

  /**
   * The proposer of the block, which represents the entity that created or proposed the block.
   */
  @jsonMember(() => ({
    name: 'proposer',
    constructor: Proposer,
    deserializer: (json: string) => Proposer.fromJSON(json),
    serializer: (value: Proposer) => value.toJSON()
  }))
  public proposer: Proposer;

  /**
   * The list of transfer hashes included in the block.
   * Transfers represent the transactions related to the movement of tokens within the blockchain.
   */
  @jsonArrayMember(() => Hash, {
    name: 'transfer_hashes',
    serializer: (value: Hash[]) => value.map(it => it.toJSON()),
    deserializer: (json: any) => json.map((it: string) => Hash.fromJSON(it))
  })
  public transferHashes: Hash[];
}

/**
 * Represents a version 2 block in the blockchain.
 * A `BlockV2` includes a hash, a header containing metadata, and the body containing the block's transactions and related data.
 */
@jsonObject
export class BlockV2 {
  /**
   * The unique hash of the block, used to identify and verify the block in the blockchain.
   */
  @jsonMember(() => ({
    name: 'hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public hash: Hash;

  /**
   * The header of the block, which contains metadata such as the block's height, parent hash, and protocol version.
   */
  @jsonMember({ name: 'header', constructor: () => BlockHeaderV2 })
  public header: BlockHeaderV2;

  /**
   * The body of the block, which contains the transactions, deploys, and other data related to the block's content.
   */
  @jsonMember({ name: 'body', constructor: () => BlockBodyV2 })
  public body: BlockBodyV2;
}

/**
 * Represents the header of a version 1 block in the blockchain.
 * The header contains metadata about the block, such as its height, parent hash, protocol version, and timestamps.
 */
@jsonObject
export class BlockHeaderV1 {
  /**
   * The accumulated seed used for randomness in block generation.
   * This seed is generated from previous blocks and influences the consensus.
   */
  @jsonMember(() => ({
    name: 'accumulated_seed',
    constructor: Hash,
    deserializer: (json: string) => {
      if (!json) return;
      return Hash.fromJSON(json);
    },
    serializer: (value: Hash) => {
      if (!value) return;
      return value.toJSON();
    }
  }))
  public accumulatedSeed?: Hash;

  /**
   * The hash of the block's body, which contains the transactions and other block data.
   * This is used to verify the integrity of the block's contents.
   */
  @jsonMember(() => ({
    name: 'body_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public bodyHash: Hash;

  /**
   * The era ID in which this block was created.
   * The era ID represents the block's position within a specific era in the blockchain.
   */
  @jsonMember({ name: 'era_id', constructor: Number })
  public eraID: number;

  /**
   * The height of the block in the blockchain.
   * The block height indicates its position relative to the first block in the chain (genesis block).
   */
  @jsonMember({ name: 'height', constructor: Number })
  public height: number;

  /**
   * The hash of the parent block, linking this block to its predecessor in the chain.
   * The parent hash is used to verify the continuity of the blockchain.
   */
  @jsonMember(() => ({
    name: 'parent_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public parentHash: Hash;

  /**
   * The protocol version used for this block, indicating the version of the consensus rules.
   */
  @jsonMember({ name: 'protocol_version', constructor: String })
  public protocolVersion?: string;

  /**
   * A random bit used for consensus, which may play a role in the block's selection or generation.
   */
  @jsonMember({ name: 'random_bit', constructor: Boolean })
  public randomBit: boolean;

  /**
   * The hash of the state root, representing the state of the blockchain after this block is applied.
   * The state root hash is used to verify the consistency of the blockchain's state.
   */
  @jsonMember(() => ({
    name: 'state_root_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public stateRootHash: Hash;

  /**
   * The timestamp indicating when the block was created.
   * This timestamp helps to determine the block's position in time within the blockchain.
   */
  @jsonMember(() => ({
    name: 'timestamp',
    constructor: Timestamp,
    deserializer: (json: string) => Timestamp.fromJSON(json),
    serializer: (value: Timestamp) => value.toJSON()
  }))
  public timestamp: Timestamp;

  /**
   * The era end details for this block's era, if available.
   * The `eraEnd` may include information about the transition from one era to another.
   */
  @jsonMember(() => ({ name: 'era_end', constructor: EraEndV1 }))
  public eraEnd?: EraEndV1;
}

/**
 * Represents the header of a version 2 block in the blockchain.
 * Contains metadata such as the block's height, parent hash, timestamp, gas price, and more.
 */
@jsonObject
export class BlockHeaderV2 {
  /**
   * The accumulated seed used for randomness in block generation.
   * This seed is generated from previous blocks and influences the consensus.
   */
  @jsonMember(() => ({
    name: 'accumulated_seed',
    constructor: Hash,
    deserializer: (json: string) => {
      if (!json) return;
      return Hash.fromJSON(json);
    },
    serializer: (value: Hash) => {
      if (!value) return;
      return value.toJSON();
    }
  }))
  public accumulatedSeed?: Hash;

  /**
   * The hash of the block's body, which contains the transactions and other data.
   * This is used to verify the integrity of the block's contents.
   */
  @jsonMember(() => ({
    name: 'body_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public bodyHash: Hash;

  /**
   * The era ID in which the block was created, indicating its position within a blockchain era.
   */
  @jsonMember({ name: 'era_id', constructor: Number })
  public eraID: number;

  /**
   * The current gas price for transactions within this block.
   */
  @jsonMember({ name: 'current_gas_price', constructor: Number })
  public currentGasPrice: number;

  /**
   * The height of the block in the blockchain, representing its position in the chain.
   */
  @jsonMember({ name: 'height', constructor: Number })
  public height: number;

  /**
   * The hash of the parent block, linking this block to its predecessor in the chain.
   */
  @jsonMember(() => ({
    name: 'parent_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public parentHash: Hash;

  /**
   * The proposer who created this block.
   */
  @jsonMember(() => ({
    name: 'proposer',
    constructor: Proposer,
    deserializer: (json: string) => Proposer.fromJSON(json),
    serializer: (value: Proposer) => value.toJSON()
  }))
  public proposer: Proposer;

  /**
   * The protocol version used for this block.
   */
  @jsonMember({ name: 'protocol_version', constructor: String })
  public protocolVersion?: string;

  /**
   * A random bit used for consensus, which may play a role in block selection or generation.
   */
  @jsonMember({ name: 'random_bit', constructor: Boolean })
  public randomBit: boolean;

  /**
   * The hash of the state root, representing the state of the blockchain after this block is applied.
   */
  @jsonMember(() => ({
    name: 'state_root_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public stateRootHash: Hash;

  /**
   * The hash of the block that switched the state, marking the end of an era or other significant event.
   */
  @jsonMember(() => ({
    name: 'last_switch_block_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public lastSwitchBlockHash: Hash;

  /**
   * The timestamp when the block was created.
   */
  @jsonMember(() => ({
    name: 'timestamp',
    constructor: Timestamp,
    deserializer: (json: string) => Timestamp.fromJSON(json),
    serializer: (value: Timestamp) => value.toJSON()
  }))
  public timestamp: Timestamp;

  /**
   * The era end details for this block's era, if available.
   */
  @jsonMember(() => ({ name: 'era_end', constructor: EraEndV2 }))
  public eraEnd?: EraEndV2;
}

/**
 * Represents the body of a version 2 block, including the transactions and rewarded signatures.
 */
@jsonObject
export class BlockBodyV2 {
  /**
   * The list of transactions included in the block.
   */
  @jsonArrayMember(BlockTransaction, {
    name: 'transactions',
    deserializer: (json: any) =>
      json.map((it: string) => BlockTransaction.fromJSON(it))
  })
  public transactions: BlockTransaction[];

  /**
   * The list of signature IDs that were rewarded in this block.
   */
  @jsonArrayMember(Number, { name: 'rewarded_signatures' })
  public rewardedSignatures: number[];
}

/**
 * A wrapper for blocks that can contain either a version 1 or version 2 block.
 */
@jsonObject
export class BlockWrapper {
  /**
   * A version 1 block, if available.
   */
  @jsonMember({ name: 'Version1', constructor: BlockV1 })
  public blockV1?: BlockV1;

  /**
   * A version 2 block, if available.
   */
  @jsonMember({ name: 'Version2', constructor: BlockV2 })
  public blockV2?: BlockV2;
}

/**
 * A block with associated proofs, which include cryptographic signatures for verification.
 */
@jsonObject
export class BlockWithSignatures {
  /**
   * The block object containing either a version 1 or version 2 block.
   */
  @jsonMember({ name: 'block', constructor: BlockWrapper })
  public block: BlockWrapper;

  /**
   * The list of proofs associated with the block, used for validating its authenticity.
   */
  @jsonArrayMember(Proof, { name: 'proofs' })
  public proofs: Proof[];
}

/**
 * A wrapper for block headers, which can contain either a version 1 or version 2 block header.
 */
@jsonObject
export class BlockHeaderWrapper {
  /**
   * A version 1 block header, if available.
   */
  @jsonMember({ name: 'Version1', constructor: BlockHeaderV1 })
  public blockHeaderV1?: BlockHeaderV1;

  /**
   * A version 2 block header, if available.
   */
  @jsonMember({ name: 'Version2', constructor: BlockHeaderV2 })
  public blockHeaderV2?: BlockHeaderV2;
}

/**
 * Represents a block header that can be either version 1 or version 2, with various metadata about the block.
 */
@jsonObject
export class BlockHeader {
  /**
   * The accumulated seed used for randomness in block generation.
   */
  @jsonMember(() => ({
    name: 'accumulated_seed',
    constructor: Hash,
    deserializer: (json: string) => {
      if (!json) return;
      return Hash.fromJSON(json);
    },
    serializer: (value: Hash) => {
      if (!value) return;
      return value.toJSON();
    }
  }))
  public accumulatedSeed?: Hash;

  /**
   * The hash of the block's body, used to verify the block's contents.
   */
  @jsonMember(() => ({
    name: 'body_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public bodyHash: Hash;

  /**
   * The era ID in which the block was created.
   */
  @jsonMember({ name: 'era_id', constructor: Number })
  public eraID: number;

  /**
   * The current gas price for transactions within this block.
   */
  @jsonMember({ name: 'current_gas_price', constructor: Number })
  public currentGasPrice: number;

  /**
   * The height of the block in the blockchain.
   */
  @jsonMember({ name: 'height', constructor: Number })
  public height: number;

  /**
   * The hash of the parent block.
   */
  @jsonMember(() => ({
    name: 'parent_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public parentHash: Hash;

  /**
   * The proposer who created this block.
   */
  @jsonMember(() => ({
    name: 'proposer',
    constructor: Proposer,
    deserializer: (json: string) => Proposer.fromJSON(json),
    serializer: (value: Proposer) => value.toJSON()
  }))
  public proposer: Proposer;

  /**
   * The protocol version used for this block.
   */
  @jsonMember({ name: 'protocol_version', constructor: String })
  public protocolVersion?: string;

  /**
   * A random bit used for consensus.
   */
  @jsonMember({ name: 'random_bit', constructor: Boolean })
  public randomBit: boolean;

  /**
   * The hash of the state root.
   */
  @jsonMember(() => ({
    name: 'state_root_hash',
    constructor: Hash,
    deserializer: (json: string) => Hash.fromJSON(json),
    serializer: (value: Hash) => value.toJSON()
  }))
  public stateRootHash: Hash;

  /**
   * The timestamp indicating when the block was created.
   */
  @jsonMember(() => ({
    name: 'timestamp',
    constructor: Timestamp,
    deserializer: (json: string) => Timestamp.fromJSON(json),
    serializer: (value: Timestamp) => value.toJSON()
  }))
  public timestamp: Timestamp;

  /**
   * The era end details, if available, for this block's era.
   */
  @jsonMember(() => ({ name: 'era_end', constructor: EraEnd }))
  public eraEnd?: EraEnd | null;

  private originBlockHeaderV1?: BlockHeaderV1;
  private originBlockHeaderV2?: BlockHeaderV2;

  /**
   * Retrieves the version 1 block header, if available.
   * @returns The version 1 block header, or `undefined` if not available.
   */
  public getBlockHeaderV1(): BlockHeaderV1 | undefined {
    return this.originBlockHeaderV1;
  }

  /**
   * Retrieves the version 2 block header, if available.
   * @returns The version 2 block header, or `undefined` if not available.
   */
  public getBlockHeaderV2(): BlockHeaderV2 | undefined {
    return this.originBlockHeaderV2;
  }

  /**
   * Creates a new `BlockHeader` instance from a version 1 block header.
   * @param header - The version 1 block header.
   * @returns A new `BlockHeader` instance.
   */
  static newBlockHeaderFromV1(header: BlockHeaderV1): BlockHeader {
    const blockHeader = new BlockHeader();
    blockHeader.accumulatedSeed = header.accumulatedSeed;
    blockHeader.bodyHash = header.bodyHash;
    blockHeader.eraID = header.eraID;
    blockHeader.currentGasPrice = 1;
    blockHeader.height = header.height;
    blockHeader.parentHash = header.parentHash;
    blockHeader.protocolVersion = header.protocolVersion;
    blockHeader.randomBit = header.randomBit;
    blockHeader.stateRootHash = header.stateRootHash;
    blockHeader.timestamp = header.timestamp;
    blockHeader.eraEnd = header.eraEnd
      ? EraEnd.fromV1(header.eraEnd)
      : undefined;
    blockHeader['originBlockHeaderV1'] = header;
    return blockHeader;
  }

  /**
   * Creates a new `BlockHeader` instance from a version 2 block header.
   * @param header - The version 2 block header.
   * @returns A new `BlockHeader` instance.
   */
  static newBlockHeaderFromV2(header: BlockHeaderV2): BlockHeader {
    const blockHeader = new BlockHeader();
    blockHeader.accumulatedSeed = header.accumulatedSeed;
    blockHeader.bodyHash = header.bodyHash;
    blockHeader.eraID = header.eraID;
    blockHeader.currentGasPrice = header.currentGasPrice;
    blockHeader.height = header.height;
    blockHeader.parentHash = header.parentHash;
    blockHeader.proposer = header.proposer;
    blockHeader.protocolVersion = header.protocolVersion;
    blockHeader.randomBit = header.randomBit;
    blockHeader.stateRootHash = header.stateRootHash;
    blockHeader.timestamp = header.timestamp;
    blockHeader.eraEnd = header.eraEnd
      ? EraEnd.fromV2(header.eraEnd)
      : undefined;
    blockHeader['originBlockHeaderV2'] = header;
    return blockHeader;
  }
}
